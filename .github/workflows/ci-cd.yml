name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  HARBOR_REGISTRY: your-harbor-registry.com
  HARBOR_PROJECT: quantflow

jobs:
  detect-changes:
    runs-on: self-hosted
    outputs:
      datacollection: ${{ steps.changes.outputs.datacollection }}
      discord: ${{ steps.changes.outputs.discord }}
      api: ${{ steps.changes.outputs.api }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: Detect changes
      id: changes
      run: |
        # Check for changes in DataCollection
        if git diff --name-only HEAD~1 HEAD | grep -E '^QuantFlow\.WorkerService\.DataCollection/|^QuantFlow\.Common/|^QuantFlow\.Data\.|^QuantFlow\.Domain/' > /dev/null; then
          echo "datacollection=true" >> $GITHUB_OUTPUT
        else
          echo "datacollection=false" >> $GITHUB_OUTPUT
        fi
        
        # Check for changes in Discord
        if git diff --name-only HEAD~1 HEAD | grep -E '^QuantFlow\.WorkerService\.Discord/|^QuantFlow\.Common/|^QuantFlow\.Data\.|^QuantFlow\.Domain/' > /dev/null; then
          echo "discord=true" >> $GITHUB_OUTPUT
        else
          echo "discord=false" >> $GITHUB_OUTPUT
        fi
        
        # Check for changes in API
        if git diff --name-only HEAD~1 HEAD | grep -E '^QuantFlow\.Api\.Rest/|^QuantFlow\.Common/|^QuantFlow\.Data\.|^QuantFlow\.Domain/' > /dev/null; then
          echo "api=true" >> $GITHUB_OUTPUT
        else
          echo "api=false" >> $GITHUB_OUTPUT
        fi

  build-datacollection:
    needs: detect-changes
    runs-on: self-hosted
    if: needs.detect-changes.outputs.datacollection == 'true' || github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test DataCollection Service
      run: |
        cd QuantFlow.WorkerService.DataCollection
        dotnet restore
        dotnet build --no-restore
        # Skip tests if no test project exists yet
        # dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push DataCollection Image
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:latest
        
        docker build -f QuantFlow.WorkerService.DataCollection/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
    
    - name: Deploy DataCollection to Development
      if: github.ref == 'refs/heads/main'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        kubectl cluster-info
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:${{ github.sha }}
        
        kubectl set image deployment/quantflow-datacollection \
          quantflow-datacollection=$IMAGE_TAG \
          -n development || \
        kubectl create deployment quantflow-datacollection \
          --image=$IMAGE_TAG \
          -n development
        
        kubectl rollout status deployment/quantflow-datacollection -n development --timeout=300s

  build-discord:
    needs: detect-changes
    runs-on: self-hosted
    if: needs.detect-changes.outputs.discord == 'true' || github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test Discord Bot
      run: |
        cd QuantFlow.WorkerService.Discord
        dotnet restore
        dotnet build --no-restore
        # Skip tests if no test project exists yet
        # dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push Discord Bot Image
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:latest
        
        docker build -f QuantFlow.WorkerService.Discord/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
    
    - name: Deploy Discord Bot to Development
      if: github.ref == 'refs/heads/main'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:${{ github.sha }}
        
        # Create Harbor registry secret if it doesn't exist
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.HARBOR_REGISTRY }} \
          --docker-username="${{ secrets.HARBOR_USERNAME }}" \
          --docker-password="${{ secrets.HARBOR_PASSWORD }}" \
          -n development --dry-run=client -o yaml | kubectl apply -f -
        
        # Create deployment with proper configuration
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-discord
          namespace: development
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantflow-discord
          template:
            metadata:
              labels:
                app: quantflow-discord
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-discord
                image: $IMAGE_TAG
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Development"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
        EOF
        
        kubectl rollout status deployment/quantflow-discord -n development --timeout=300s

  build-api:
    needs: detect-changes
    runs-on: self-hosted
    if: needs.detect-changes.outputs.api == 'true' || github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test API
      run: |
        cd QuantFlow.Api.Rest
        dotnet restore
        dotnet build --no-restore
        # Skip tests if no test project exists yet
        # dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push API Image
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:latest
        
        docker build -f QuantFlow.Api.Rest/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
    
    - name: Deploy API to Development
      if: github.ref == 'refs/heads/main'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:${{ github.sha }}
        
        # Create Harbor registry secret if it doesn't exist
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.HARBOR_REGISTRY }} \
          --docker-username="${{ secrets.HARBOR_USERNAME }}" \
          --docker-password="${{ secrets.HARBOR_PASSWORD }}" \
          -n development --dry-run=client -o yaml | kubectl apply -f -
        
        # Create deployment with proper configuration
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-api
          namespace: development
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: quantflow-api
          template:
            metadata:
              labels:
                app: quantflow-api
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-api
                image: $IMAGE_TAG
                ports:
                - containerPort: 8080
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Development"
                - name: ASPNETCORE_URLS
                  value: "http://*:8080"
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "200m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 5
                  periodSeconds: 5
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: quantflow-api-service
          namespace: development
        spec:
          selector:
            app: quantflow-api
          ports:
          - port: 80
            targetPort: 8080
            protocol: TCP
          type: ClusterIP
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: quantflow-api-ingress
          namespace: development
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /
        spec:
          rules:
          - host: api-dev.quantflow.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: quantflow-api-service
                    port:
                      number: 80
        EOF
        
        kubectl rollout status deployment/quantflow-api -n development --timeout=300s

  deploy-production:
    needs: [build-datacollection, build-discord, build-api]
    runs-on: self-hosted
    # DISABLED: Production deployments temporarily disabled
    if: false
    # Original condition: github.ref == 'refs/heads/main' && (needs.build-datacollection.result == 'success' || needs.build-discord.result == 'success' || needs.build-api.result == 'success')
    environment: production
    
    steps:
    - name: Deploy DataCollection to Production
      if: needs.build-datacollection.result == 'success'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:${{ github.sha }}
        
        kubectl set image deployment/quantflow-datacollection \
          quantflow-datacollection=$IMAGE_TAG \
          -n production || \
        kubectl create deployment quantflow-datacollection \
          --image=$IMAGE_TAG \
          -n production
        
        kubectl rollout status deployment/quantflow-datacollection -n production --timeout=300s
    
    - name: Deploy Discord Bot to Production
      if: needs.build-discord.result == 'success'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:${{ github.sha }}
        
        # Create Harbor registry secret if it doesn't exist
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.HARBOR_REGISTRY }} \
          --docker-username="${{ secrets.HARBOR_USERNAME }}" \
          --docker-password="${{ secrets.HARBOR_PASSWORD }}" \
          -n production --dry-run=client -o yaml | kubectl apply -f -
        
        # Create deployment with proper configuration
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-discord
          namespace: production
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantflow-discord
          template:
            metadata:
              labels:
                app: quantflow-discord
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-discord
                image: $IMAGE_TAG
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
        EOF
        
        kubectl rollout status deployment/quantflow-discord -n production --timeout=300s
    
    - name: Deploy API to Production
      if: needs.build-api.result == 'success'
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:${{ github.sha }}
        
        # Create Harbor registry secret if it doesn't exist
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.HARBOR_REGISTRY }} \
          --docker-username="${{ secrets.HARBOR_USERNAME }}" \
          --docker-password="${{ secrets.HARBOR_PASSWORD }}" \
          -n production --dry-run=client -o yaml | kubectl apply -f -
        
        # Create deployment with proper configuration
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-api
          namespace: production
        spec:
          replicas: 3
          selector:
            matchLabels:
              app: quantflow-api
          template:
            metadata:
              labels:
                app: quantflow-api
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-api
                image: $IMAGE_TAG
                ports:
                - containerPort: 8080
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                - name: ASPNETCORE_URLS
                  value: "http://*:8080"
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "500m"
                  limits:
                    memory: "1Gi"
                    cpu: "1000m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 5
                  periodSeconds: 5
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: quantflow-api-service
          namespace: production
        spec:
          selector:
            app: quantflow-api
          ports:
          - port: 80
            targetPort: 8080
            protocol: TCP
          type: ClusterIP
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: quantflow-api-ingress
          namespace: production
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
        spec:
          tls:
          - hosts:
            - api.quantflow.com
            secretName: quantflow-api-tls
          rules:
          - host: api.quantflow.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: quantflow-api-service
                    port:
                      number: 80
        EOF
        
        kubectl rollout status deployment/quantflow-api -n production --timeout=300s
