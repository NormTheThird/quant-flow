name: QuantFlow Multi-Project CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  HARBOR_REGISTRY: "10.47.1.106"
  HARBOR_PROJECT: "library"

jobs:
  # BUILD PHASE - All run in parallel
  build-datacollection:
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test DataCollection
      run: |
        cd QuantFlow.WorkerService.DataCollection
        dotnet restore
        dotnet build --no-restore
        dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push DataCollection Image
      id: build
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-datacollection:latest
        
        docker build -f QuantFlow.WorkerService.DataCollection/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  build-discord:
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test Discord Bot
      run: |
        cd QuantFlow.WorkerService.Discord
        dotnet restore
        dotnet build --no-restore
        # dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push Discord Bot Image
      id: build
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-discord:latest
        
        docker build -f QuantFlow.WorkerService.Discord/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  build-api:
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .NET Installation
      run: dotnet --version
    
    - name: Build and Test API
      run: |
        cd QuantFlow.Api.Rest
        dotnet restore
        dotnet build --no-restore
        dotnet test --no-build --verbosity normal
    
    - name: Login to Harbor
      run: |
        echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ env.HARBOR_REGISTRY }} \
          --username "${{ secrets.HARBOR_USERNAME }}" --password-stdin
    
    - name: Build and Push API Image
      id: build
      run: |
        IMAGE_TAG=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:${{ github.sha }}
        IMAGE_LATEST=${{ env.HARBOR_REGISTRY }}/${{ env.HARBOR_PROJECT }}/quantflow-api:latest
        
        docker build -f QuantFlow.Api.Rest/Dockerfile -t $IMAGE_TAG -t $IMAGE_LATEST .
        docker push $IMAGE_TAG
        docker push $IMAGE_LATEST
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  # TEST/STAGING DEPLOYMENT PHASE - Runs after all builds complete
  deploy-test:
    needs: [build-datacollection, build-discord, build-api]
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'
    environment: test
    
    steps:
    - name: Setup Kubernetes Config
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl cluster-info
    
    - name: Create Harbor Registry Secret
      run: |
        export KUBECONFIG=kubeconfig
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.HARBOR_REGISTRY }} \
          --docker-username="${{ secrets.HARBOR_USERNAME }}" \
          --docker-password="${{ secrets.HARBOR_PASSWORD }}" \
          -n test --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy DataCollection Service
      if: needs.build-datacollection.result == 'success'
      run: |
        export KUBECONFIG=kubeconfig
        IMAGE_TAG=${{ needs.build-datacollection.outputs.image-tag }}
        
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-datacollection
          namespace: test
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantflow-datacollection
          template:
            metadata:
              labels:
                app: quantflow-datacollection
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-datacollection
                image: $IMAGE_TAG
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "200m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
        EOF
        
        kubectl rollout status deployment/quantflow-datacollection -n test --timeout=300s
    
    - name: Deploy Discord Bot Service
      if: needs.build-discord.result == 'success'
      run: |
        export KUBECONFIG=kubeconfig
        IMAGE_TAG=${{ needs.build-discord.outputs.image-tag }}
        
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-discord
          namespace: test
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantflow-discord
          template:
            metadata:
              labels:
                app: quantflow-discord
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-discord
                image: $IMAGE_TAG
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
        EOF
        
        kubectl rollout status deployment/quantflow-discord -n test --timeout=300s
    
    - name: Deploy API Service
      if: needs.build-api.result == 'success'
      run: |
        export KUBECONFIG=kubeconfig
        IMAGE_TAG=${{ needs.build-api.outputs.image-tag }}
        
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantflow-api
          namespace: test
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantflow-api
          template:
            metadata:
              labels:
                app: quantflow-api
            spec:
              imagePullSecrets:
              - name: harbor-registry
              containers:
              - name: quantflow-api
                image: $IMAGE_TAG
                ports:
                - containerPort: 8080
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                - name: ASPNETCORE_URLS
                  value: "http://*:8080"
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "200m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 5
                  periodSeconds: 5
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: quantflow-api-service
          namespace: test
        spec:
          selector:
            app: quantflow-api
          ports:
          - port: 8080
            targetPort: 8080
            protocol: TCP
          type: NodePort
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: quantflow-api-ingress
          namespace: test
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /
        spec:
          rules:
          - host: api-test.quantflow.local
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: quantflow-api-service
                    port:
                      number: 8080
        EOF
        
        kubectl rollout status deployment/quantflow-api -n test --timeout=300s

  # PRODUCTION DEPLOYMENT PHASE - Placeholder for future implementation
  deploy-production:
    needs: [build-datacollection, build-discord, build-api, deploy-test]
    runs-on: self-hosted
    if: false  # Disabled for now - will be enabled when production deployment is ready
    environment: production
    
    steps:
    - name: Production Deployment Placeholder
      run: |
        echo "Production deployment will be implemented later"
        echo "This job is currently disabled via 'if: false' condition"
